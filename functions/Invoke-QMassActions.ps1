function Invoke-QMassActions {
    <#
.SYNOPSIS
    This script performs massive parallel execution custom PowerShell code on computers group.
.DESCRIPTION
    There are two execution modes - locally or inside remote PSSession.

    === LOCAL CODE EXECUTION ===
    Special variable $pssession is available for using in code.
    $pssession is represents each target computer and available only for this mode.
    Enable with '$InvokeContext = "Local"'. Example code:

    $SourceFile = "C:\testfile.txt"
    $DestFile = "D:\CatalogTest\testfile_$($pssession.ComputerName)"
    Copy-Item -Path $SourceFile -FromSession $pssession -Destination $DestFile

    This code execute locally and copies file from each computer (PSSession) to local catalog.

    === EXECUTION INSIDE REMOTE PSSESSION ===
    Enable with '$InvokeContext = "InPSSession"'. Example code:

    $RawSize = Get-Volume -DriveLetter "C" | Select-Object -ExpandProperty "SizeRemaining"
    $RoundedSize = [System.Math]::Round(($RawSize/1GB), 2)
    "$RoundedSize GB"

    This code execute remotely inside each PSSession and return size of disk "C" from each computer.
.NOTES
    ONLY FOR POWERSHELL 7.2 AND HIGHER
.PARAMETER Computers
    Specifies array of computer names. Type NetBIOS name or FQDN of one or more remote computers.
.PARAMETER Code
    Specifies PowerShell code (as string) that you want to execute.
.PARAMETER Credential
    Specifies user account that has permission on target computers to do this action. Default is current user.
    Type user name, such as User01 or Domain01\User01, or enter PSCredential object generated by Get-Credential cmdlet. If you type user name, you're prompted to enter password.
    Credentials are stored in PSCredential object and password is stored as SecureString.
.PARAMETER CredSSP
    Specifies CredSSP authentication mode for PSSession. Valid only with Credential parameter. Default authentication mode - Kerberos.
.PARAMETER InvokeContext
    Specifies where code will be executed.
    "Local" - your code will be executed locally and you may use variable $pssession (PSSession for each computer) in your code.
    "InPSSession" - your code will be executed inside remote PSSession.
.PARAMETER LogFile
    Specifies path to log file.
    If not specified, it will be created in same directory as script.
.PARAMETER Threads
    Specifies the number of script blocks that run in parallel. Default - 10.
.EXAMPLE
    $Servers = Get-Content -Path ".\servers.txt"
    $MyCode = Get-Content -Path "C:\scripts\mycode.ps1"
    Invoke-QMassActions -Computers $Servers -Code $MyCode -InvokeContext "Local" -LogFile "C:\Logs\updates.log"

    This code will be executed locally.
    Connection will be made with current credentials.
    Log file - "C:\Logs\updates.log".
    Default 10 threads (parallel processing).
.EXAMPLE
    $Credential = Get-Credential
    $Params = @{
        Computers = "computer1", "computer2"
        Code = "Get-Volume -DriveLetter 'C'"
        Credential = $Credential
        InvokeContext = "InPSSession"
        Threads = 1
        LogFile = "C:\Logs\disk_c.log"
    }
    Invoke-QMassActions @Params

    This code will be executed inside each PSSession.
    Use custom credentials from interactive input.
    Log file - "C:\Logs\disk_c.log".
    1 thread (no parallel processing).
.EXAMPLE
    $Credential = Get-Credential
    $Params = @{
        Computers = Get-Content -Path ".\servers.txt"
        Code = "Copy-Item -Path '\\share\Image.iso' -Destination 'C:\Images\'"
        Credential = $Credential
        CredSSP = $true
        InvokeContext = "InPSSession"
        Threads = 5
        LogFile = "C:\Logs\copy_image.log"
    }
    Invoke-QMassActions @Params

    This code will be executed inside each PSSession.
    Use custom credentials from interactive input.
    Use CredSSP authentication mode to address second hop problem.
    Log file - "C:\Logs\copy_image.log".
    5 thread (parallel processing).
.INPUTS
    None.
.OUTPUTS
    None.
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string[]]$Computers,
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$Code,
        [Parameter(Mandatory = $false)]
        [pscredential]$Credential,
        [Parameter(Mandatory = $false)]
        [switch]$CredSSP,
        [Parameter(Mandatory = $true)]
        [ValidateSet("Local", "InPSSession")]
        [string]$InvokeContext,
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path -Path $_ -PathType "Leaf" -IsValid })]
        [string]$LogFile,
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [int]$Threads = 10
    )
    
    begin {
        $ErrorActionPreference = "Stop"

        # Create log file
        New-Item -Path $LogFile -ItemType "File" -Force | Out-Null
        "START:  $(Get-Date -Format s)" | Out-File -FilePath $LogFile
        if ($Credential) {
            "Credential: $($Credential.UserName)" | Out-File -FilePath $LogFile -Append
        }
        else {
            "Credential: <current user>" | Out-File -FilePath $LogFile -Append
        }
        if ($CredSSP -eq $true) {
            $Authentication = "Credssp"
        }
        else {
            $Authentication = "Kerberos"
        }
        "Authentication: $Authentication" | Out-File -FilePath $LogFile -Append
        "InvokeContext: $InvokeContext`n" | Out-File -FilePath $LogFile -Append

        # Create dictionary for collect logs from parallel PowerShell threads
        $LogDictionary = [System.Collections.Concurrent.ConcurrentDictionary[string, System.Object]]::new()
    }
    
    process {
        $Computers | ForEach-Object -ThrottleLimit $Threads -Parallel {
            [string]$ComputerName = $_
            if ($Using:Credential) {
                [pscredential]$Credential = $Using:Credential
            }
            [System.Collections.Concurrent.ConcurrentDictionary[string, System.Object]]$Log = $Using:LogDictionary
            $ErrorActionPreference = "Stop"

            # Check WinRM port
            [bool]$TestWinRMport = Test-NetConnection -CommonTCPPort "WINRM" -ComputerName $ComputerName -InformationLevel "Quiet"
            if ($TestWinRMport -eq $true) {
                try {
                    # Create PSSession
                    if ($Credential) {
                        [System.Management.Automation.Runspaces.PSSession]$pssession = New-PSSession -ComputerName $ComputerName -Authentication $Using:Authentication -Credential $Using:Credential -ErrorAction "Stop"
                    }
                    else {
                        [System.Management.Automation.Runspaces.PSSession]$pssession = New-PSSession -ComputerName $ComputerName -Authentication $Using:Authentication -ErrorAction "Stop"
                    }

                    # Execution and get result
                    try {
                        # Invoke target code
                        if ($Using:InvokeContext -eq "InPSSession") {
                            [string]$Result = Invoke-Command -Session $pssession -ScriptBlock ([scriptblock]::Create($Using:Code)) -ErrorAction "Stop"
                        }
                        else {
                            [string]$Result = Invoke-Command -ScriptBlock ([scriptblock]::Create($Using:Code)) -NoNewScope -ErrorAction "Stop"
                        }
                        
                        # Store success result
                        if ($Result) {
                            # If target code has text output
                            [string]$Msg = "SUCCESS:  $($Result.ToString())"
                        }
                        else {
                            # If target code has no output
                            [string]$Msg = "SUCCESS:  <no output>"
                        }
                    }
                    catch {
                        # Store fail result
                        [string]$Msg = "FAIL:  error code execution:`n$_"
                    }
                }
                catch {
                    # If creation PSSession failure
                    [string]$Msg = "FAIL:  PSSession fail"
                }

                # Cleanup
                finally {
                    if ($pssession) {
                        Remove-PSSession -Session $pssession
                    }
                }
            }
            else {
                # If WinRM port is unavailable
                [string]$Msg = "FAIL:  WinRM port fail"
            }

            # Output to screen
            if ($Msg -match "SUCCESS") {
                Write-Host -Object "$($ComputerName): $Msg`n" -ForegroundColor "Green"
            }
            else {
                Write-Host -Object "$($ComputerName): $Msg`n" -ForegroundColor "Red"
            }

            # Save result to dictionary
            $Log.TryAdd($ComputerName, $Msg) | Out-Null
        }
    }
    
    end {
        # Count successful computers
        [int]$SuccessComputersCount = ($LogDictionary.ToArray() | Where-Object -FilterScript { $_.Value -Match "SUCCESS" }).Count

        # Save result to log file
        [string[]]$Output = @()
        $LogDictionary.ToArray() | Sort-Object -Property "Key" | ForEach-Object -Process {
            $Output += "$($_.Key.ToString()): $($_.Value.ToString())`n"
        }
        $Output | Out-File -FilePath $LogFile -Append
        "`nSuccess:  $SuccessComputersCount computers from $($Computers.Count)" | Out-File -FilePath $LogFile -Append
        "FINISH:  $(Get-Date -Format s)" | Out-File -FilePath $LogFile -Append

        # Output brief to screen
        Write-Host -Object "`nSuccess:  $SuccessComputersCount computers from $($Computers.Count)" -ForegroundColor "Cyan"
    }
}